[{"title":"PHP-Parser的基本使用","url":"/2022/01/28/PHP-Parser/","content":"PHP-ParserPHP-Parser组件的基础使用，该组件为静态分析和反混淆常用的第三方依赖。\n\n\nWhat is PHP-ParserPHP-Parser是nikic用PHP编写的PHP5.2到PHP7.4解析器，其目的是简化静态代码分析和操作\nPHP-Parser的基础使用这里先贴一下官方文档\nPHP-Parser/doc at master · nikic/PHP-Parser (github.com)\n最基本的是要理解其中Walking the AST的部分\n初始化解析器首先创建实例\nuse PhpParser\\ParserFactory;$parser = (new ParserFactory)-&gt;create(ParserFactory::PREFER_PHP7);\n\n这其中有以下参数\nKindBehaviorParserFactory::PREFER_PHP7Try to parse code as PHP 7. If this fails, try to parse it as PHP 5.ParserFactory::PREFER_PHP5Try to parse code as PHP 5. If this fails, try to parse it as PHP 7.ParserFactory::ONLY_PHP7Parse code as PHP 7.ParserFactory::ONLY_PHP5Parse code as PHP 5.\ncreate还有一个参数Lexer，这里先不做讨论\n在实例化之后我们就可以通过\n$stmts = $parser-&gt;parse($code);\n\n来将代码转换成AST\n为了防止抛出异常，最好在try….catch中执行\n生成更加直观的AST当我们var_dump上面的$stmt时，会得到一个比较乱的AST，可以使用NodeDump将其转化为更加直观的AST\n这里需要使用NodeDump\n对于代码\n&lt;?phpfunction printLine($msg) &#123;    echo $msg, &quot;\\n&quot;;&#125;printLine(&#x27;Hello World!!!&#x27;);\n\n将其转换为AST\n&lt;?phpuse PhpParser\\NodeDumper;$nodeDumper = new NodeDumper;echo $nodeDumper-&gt;dump($stmts), &quot;\\n&quot;;\n\n得到以下输出\narray(    0: Stmt_Function(        byRef: false        name: Identifier(            name: printLine        )        params: array(            0: Param(                type: null                byRef: false                variadic: false                var: Expr_Variable(                    name: msg                )                default: null            )        )        returnType: null        stmts: array(            0: Stmt_Echo(                exprs: array(                    0: Expr_Variable(                        name: msg                    )                    1: Scalar_String(                        value:                    )                )            )        )    )    1: Stmt_Expression(        expr: Expr_FuncCall(            name: Name(                parts: array(                    0: printLine                )            )            args: array(                0: Arg(                    value: Scalar_String(                        value: Hello World!!!                    )                    byRef: false                    unpack: false                )            )        )    ))\n\nNode tree structure上面我们可以看到生成了很多的Node类型\nPHP是一个成熟的脚本语言，它大约有140个不同的节点。但是为了方便使用，将他们分为三类：\n\nPhpParser\\Node\\Stmts是语句节点，即不返回值且不能出现在表达式中的语言构造。例如，类定义是一个语句，它不返回值，你不能编写类似func(class {})的语句。\n\nPhpParser\\Node\\expr是表达式节点，即返回值的语言构造，因此可以出现在其他表达式中。如：$var (PhpParser\\Node\\Expr\\Variable)和func() (PhpParser\\Node\\Expr\\FuncCall)。\n\nPhpParser\\Node\\Scalars是表示标量值的节点，如&quot;string&quot; (PhpParser\\Node\\scalar\\string)、0 (PhpParser\\Node\\scalar\\LNumber) 或魔术常量，如”FILE“ (PhpParser\\Node\\scalar\\MagicConst\\FILE) 。所有PhpParser\\Node\\scalar都是延伸自PhpParser\\Node\\Expr，因为scalar也是表达式。\n\n需要注意的是PhpParser\\Node\\Name和PhpParser\\Node\\Arg不在以上的节点之中\n\n\nPretty printerPrettyprinter用来将我们修改后的AST转换回PHP代码，使用如下\nuse PhpParser\\Error;use PhpParser\\ParserFactory;use PhpParser\\PrettyPrinter;$code = &quot;&lt;?php echo &#x27;Hi &#x27;, hi\\\\getTarget();&quot;;$parser = (new ParserFactory)-&gt;create(ParserFactory::PREFER_PHP7);$prettyPrinter = new PrettyPrinter\\Standard;try &#123;    //生成AST    $stmts = $parser-&gt;parse($code);    //对节点进行操作    $stmts[0]         // the echo statement          -&gt;exprs     // sub expressions          [0]         // the first of them (the string node)          -&gt;value     // it&#x27;s value, i.e. &#x27;Hi &#x27;          = &#x27;Hello &#x27;; // change to &#x27;Hello &#x27;    // pretty print    $code = $prettyPrinter-&gt;prettyPrint($stmts);    echo $code;&#125; catch (Error $e) &#123;    echo &#x27;Parse Error: &#x27;, $e-&gt;getMessage();&#125;\n\n在反混淆中我们一般很少使用$stmts[0]这种方式，因为我们要考虑节点的各种类型\n此外还有prettyPrintExpr()，它可以用来输出一个表达式类型的节点\n例如当你需要提取全局变量时\n&lt;?php    $a = $_POST[&#x27;a&#x27;];\n\n他的语法树如下\n0: Stmt_Expression(        expr: Expr_Assign(            var: Expr_Variable(                name: a            )            expr: Expr_ArrayDimFetch(                var: Expr_Variable(                    name: _POST                )                dim: Scalar_String(                    value: a                )            )        )    )\n\n如果我想获取$_POST[‘a’],我就需要先判断节点类型是不是Expr_ArrayDimFetch\n然后判断$node-&gt;var-&gt;name是不是全局变量\n最后提取$node-&gt;var-&gt;name和$node-&gt;dim-&gt;value然后将它们拼接\n当我的全局变量为$_POST[a]时，dim部分的AST也会变化，我们还需要考虑这种情况。\n但是我们可以使用\n/*    用来识别全局变量;    如果要获取全局变量格式无需考虑value的节点类型    expr: Expr_ArrayDimFetch(            var: Expr_Variable(                name: _POST            )    )*/        if ($node instanceof Node\\Expr\\ArrayDimFetch &amp;&amp; $node-&gt;var instanceof Node\\Expr\\Variable &amp;&amp; (in_array($node-&gt;var-&gt;name ,GLOBAL_VAR)))        &#123;            self::$globalname = $this-&gt;prettyPrinter-&gt;prettyPrintExpr($node);        &#125;\n\n其中\n$this-&gt;prettyPrinter-&gt;prettyPrintExpr($node);\n\n就会返回该Expr节点的表达式，无论是$_POST[&#39;a&#39;]还是$_POST[a]都可以正常返回\nPHP-Parser/Pretty_printing.markdown at master · nikic/PHP-Parser (github.com)\nNode traversation我们使用PHP-Parser对文件的节点进行修改，最关键的就是编写节点遍历操作\n使用PhpParser\\NodeTraverser我们可以遍历每一个节点，举几个简单的例子：解析php中的所有字符串，并输出\n&lt;?phpuse PhpParser\\Error;use PhpParser\\ParserFactory;use PhpParser\\NodeTraverser;use PhpParser\\NodeVisitorAbstract;use PhpParser\\Node;require &#x27;vendor/autoload.php&#x27;;class MyVisitor extends NodeVisitorAbstract&#123;    public function leaveNode(Node $node)    &#123;        //判断如果是一个String_节点，就输出        if ($node instanceof Node\\Scalar\\String_)        &#123;            echo $node -&gt; value,&quot;\\n&quot;;        &#125;    &#125;&#125;$code = file_get_contents(&quot;./test.php&quot;);//实例化解释器$parser = (new ParserFactory)-&gt;create(ParserFactory::PREFER_PHP7);$traverser = New NodeTraverser;//添加自己的Visitor$traverser-&gt;addVisitor(new MyVisitor);try &#123;    //转化AST    $ast = $parser-&gt;parse($code);    //开始遍历    $stmts = $traverser-&gt;traverse($ast);&#125; catch (Error $error) &#123;    echo &quot;Parse error: &#123;$error-&gt;getMessage()&#125;\\n&quot;;    return;&#125;?&gt;\n\n替换php脚本中函数以及类的成员方法函数名为小写\nclass MyVisitor extends NodeVisitorAbstract&#123;    public function leaveNode(Node $node)    &#123;        if( $node instanceof Node\\Expr\\FuncCall) &#123;            $node-&gt;name-&gt;parts[0]=strtolower($node-&gt;name-&gt;parts[0]);        &#125;elseif($node instanceof Node\\Stmt\\ClassMethod)&#123;            $node-&gt;name-&gt;name=strtolower($node-&gt;name-&gt;name);        &#125;elseif ($node instanceof Node\\Stmt\\Function_)&#123;            $node-&gt;name-&gt;name=strtolower($node-&gt;name-&gt;name);        &#125;elseif($node instanceof Node\\Expr\\MethodCall)&#123;            $node-&gt;name-&gt;name=strtolower($node-&gt;name-&gt;name);        &#125;    &#125;&#125;\n\n需要注意的是所有的visitors都必须实现PhpParser\\NodeVisitor接口，该接口定义了如下4个方法：\npublic function beforeTraverse(array $nodes);public function enterNode(\\PhpParser\\Node $node);public function leaveNode(\\PhpParser\\Node $node);public function afterTraverse(array $nodes);\n\n\nbeforeTraverse方法在遍历开始之前调用一次，并将其传递给调用遍历器的节点。此方法可用于在遍历之前重置值或准备遍历树。\n\nafterTraverse方法与beforeTraverse方法类似，唯一的区别是它只在遍历之后调用一次。\n\n在每个节点上都调用enterNode和leaveNode方法，前者在它被输入时，即在它的子节点被遍历之前，后者在它被离开时。\n\n这四个方法要么返回更改的节点，要么根本不返回(即null)，在这种情况下，当前节点不更改。\n\n\n例子基于 AST（抽象语法树）解 PHP 混淆 | J0k3r’s Blog\nP.S.我们需要知道你需要什么样的Node，进行什么样的操作，Node下数据的格式会有哪几种情况，会不会因为代码不够严谨导致错误或者无限递归\n","tags":["PHP-Parser","PHP"]},{"title":"毕设项目:基于PHP-Parser进行反混淆与检测的规划","url":"/2022/02/10/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E3%81%AE%E6%83%B3%E6%B3%95/","content":"对于自己的毕设的一些功能的想法和未来该怎么做的一些规划\n\n\n毕设项目-基于PHP-Parser的反混淆前言大致设想是使用PHP-Parser完成反混淆，然后结合Yara进行检测。\n目前是没考虑过机器学习，后续可能会使用吧(maybe\n反混淆PHP-Parser基础来源于FeatureExtract中积累的操作\n根据Github上的反混淆项目和Deof项目进行改造，尽量理解两个项目的运行方式以及对待不同混淆时的操作\nDeobf编写比较有逻辑，整体框架一目了然，对应文件的功能比较清晰\n但是现在功能不够全，对于一些情况目前无法处理，比如\n&lt;?php $z0=$_REQUEST[&#x27;sort&#x27;];$q1=&#x27;&#x27;;$c2=&quot;wt8m4;6eb39fxl*s5/.yj7(pod_h1kgzu0cqr)aniv2&quot;;$y3=array(8,38,15,7,6,4,26,25,7,34,24,25,7);foreach($y3 as $h4) &#123;\t$q1.=$c2[$h4];&#125;$v5=strrev(&quot;noi&quot;.&quot;tcnuf&quot;.&quot;_eta&quot;.&quot;erc&quot;);$j6=$v5(&quot;&quot;,$q1($z0));$j6();?&gt;\n\n在$j6=$v5(&quot;&quot;,$q1($z0));这里不能直接反混淆出v5的值\n还有一些其他的功能没有实现，只实现了基础的反混淆，不过因为骨架已经搭好，未来应该在该项目基础上进行编写\n一些常用的反混淆操作字符串函数直接返回值这里以base64_decode为例，后续可以把字符串操作函数放在数组里然后进行判断\nfunction leavenode($node)&#123;    if($node instanceof PhpParser\\Node\\Expr\\FuncCall &amp;&amp; $node-&gt;name-&gt;parts[0] == &quot;base64_decode&quot;)&#123;        return new PhpParser\\Node\\Scalar\\String_($node-&gt;name-&gt;parts[0]($node-&gt;args[0]-&gt;value-&gt;value));    &#125;&#125;//例子如下&lt;?phpbase64_decode(&quot;UEhQLVBhcnNlcg&quot;);--After parser:--    &lt;?php&#x27;PHP-Parser&#x27;;\n\n\n字符操作函数传递给变量然后动态调用这个目前我没有啥好的想法，我的做法是设置两个Visitor，第一个Visitor遍历到函数声明的时候把函数名和函数值存在一个static数组里，第二个Visitor为进行操作的，当遍历到$node为函数调用时，去数组里进行查询，返回对应变量的值，然后返回成String_节点\n目前只写了针对单字符编码的测试，还有的函数需要多个参数，参数可能为字符也可能为变量，这里后续要考虑(初级想法是argv[]依次取出通过循环拼接命令，后续进行尝试)，还有要设计数据结构，变量可以给变量复制，是不是可以使用链表进行操作，终点指向字符串等。\nClass StrVisitor extends NodeVisitorAbstract&#123;    public function __construct()    &#123;        $this-&gt;variable = new Variable;    &#125;    function leavenode($node)&#123;        if($node instanceof PhpParser\\Node\\Expr\\Assign &amp;&amp; $node-&gt;var instanceof PhpParser\\Node\\Expr\\Variable &amp;&amp; $node-&gt;expr instanceof PhpParser\\Node\\Scalar\\String_) &#123;            $this-&gt;variable-&gt;pushvariable($node-&gt;var-&gt;name,$node-&gt;expr-&gt;value);        &#125;    &#125;    function afterTraverse(array $nodes)    &#123;        $this-&gt;variable-&gt;output();    &#125;&#125;Class FuncVisitor extends NodeVisitorAbstract&#123;    public function __construct()    &#123;        $this-&gt;variable = new Variable;    &#125;    function leavenode($node)&#123;        if($node instanceof PhpParser\\Node\\Expr\\FuncCall &amp;&amp; $node-&gt;name instanceof PhpParser\\Node\\Expr\\Variable) &#123;            $value = $node-&gt;args[0]-&gt;value-&gt;value;            $name = $this-&gt;variable-&gt;popvariable($node-&gt;name-&gt;name);            if($name)&#123;                return new Node\\Scalar\\String_($name($value));            &#125;        &#125;    &#125;&#125;Class Variable&#123;    static $variablelist = [];    public function pushvariable($variablename,$variablevalue)&#123;        self::$variablelist[$variablename] = $variablevalue;    &#125;    public function popvariable($variablename)&#123;        if(isset(self::$variablelist[$variablename]))&#123;            return self::$variablelist[$variablename];        &#125;else&#123;            return 0;        &#125;    &#125;    public function output()&#123;        var_dump(self::$variablelist);    &#125;&#125;\n\n测试如下\n&lt;?php$a = &#x27;base64_decode&#x27;;$b = &#x27;str_rot13&#x27;;$c = &#x27;chr&#x27;;$d = &#x27;strtolower&#x27;;$d(&#x27;@_POST&#x27;);$c(97);$b(&#x27;CUC-Cnefre&#x27;);--After parser:--&lt;?php$a = &#x27;base64_decode&#x27;;$b = &#x27;str_rot13&#x27;;$c = &#x27;chr&#x27;;$d = &#x27;strtolower&#x27;;&#x27;@_post&#x27;;&#x27;a&#x27;;&#x27;PHP-Parser&#x27;;\n针对preg_replace这种多参数函数，php_deobf可以进行混淆出来，后续看一下怎么实现的这里挖个坑，每天补一点\nYaraYara规则依靠于积累的规则和开源项目例如\nyara_rules/gen_webshells.yar\n目前的想法是将工作的重点放在反混淆上，因为如果能将反混淆做的尽量彻底，那么规则就会很好写。\n两者结合做一个后端或者直接在反混淆结束之后添加\nsystem(&quot;yara -r webshell/rule webshell/sample&quot;);\n\n如果有时间还是想做一个好看的后端\n短期要做的事\n看一下**PHPDeobfuscator**是怎么解决变量值的存储和后续替换的(目前的想法是如果遍历到遍历声明或者变量赋值，就把变量名和值传给一个数组，当后续遇到变量被调用时从数组调值进行替换，明天试试)\n将Deobf当前的功能理清楚然后将目前已经可以做的补充进去\n调研一下后端的建设情况\n\n","tags":["PHP-Parser"]}]